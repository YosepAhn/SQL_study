7장 

 테이블의 분리 >> 필요성

  1) 열의 값이 원자적이지 않을 때
      원자적 데이터 원리 (제 1 정규화)를 위반하고 있을때 
      -> 한 열의 두개 이상(한 열의 열값이 원자적 X)의 데이터가 들어있을 때(비원자적 칼럼)
  2) 원자적 데이터로 구성된 테이블은 같은 타입(자료형을 말하는거 아님을 주의)의 데이터를 여러 열에 가지고 있을때 
      -> 유사한 내용의 원자적 데이터를 2개의 이상의 서로 다른 칼럼에 상용했을 때 
   * 별도의 테이블로 옮겨야 함 ! 


 테이블의 분리>>중복 데이터의 문제

  - 논리적, 공간적 문제 발생 가능성 높음
      논리적 : 사람의 이름을 매번 기술, 이런 과정에서 오타, 동명이인인 경우 구별 불가능
      공간적 : 동일한 이름이 계속 공간을 차지


 참조키(FOREIGN KEY) >> 정의

  정의 :참조키는 테이블의 한 열로, 다른 테이블의 기본키의 값을가지는 열
    1) 참조키에서 참조하는 기본키와 다른 이름일 수도 있다.
    2) 참조키에서 참조하는 기본키는 부모키 
    3) 부모키있는 테이블은 부모테이블
    4) 기본키는 NULL일수 없지만 참조키는 가능
    5) 참조키는 유일할 필요 X
  
  제약조건 
    참조무결성 : 참조키의 값으로는 부모 테이블에 조재하는 키의 값만을 넣을수 있다.
      - 이러한 규칙 위반할 경우 DB에서 에러 발생(테이블에 외부키로 설정한 경우)
      - 참조키를 사용하여 부모 테이블의 유일한 값을 참조 할 수 있음

    - profession 테이블의 prof_id(기본키(PRIMARY KEY))와  my_contacts 테이블의 frof_id(참조키(FOREIGN KEY))연결
    -> ALTER TABLE my_contacts ADD FOREIGN KEY (prof_id) REFERENCES profession(prof_id);


 테이블간의 관계 >> 1-1, 1-N, N-N 관계

   1-1 : 하나의 테이블의 한행이 다른테이블의 하나의 행과 연관 되는 경우 
         ->보통의 경우에는 1-1관계를 위해 별도의 테이블을 사용할 이유 없음
      예외) 개인정보보호 차원에서 별도의 테이블에 넣고 접근 권한을 조정하고 싶은 경우 등
   1-N : 테이블 A의 한 레코드가 테이블B의 여러 레코드와 연결되지만, 테비블 B의 한 레코드는 테이블 A의 한 레코드에만 연결되는 경우
       ex) 하나의 직업은 여러사람의 직업이 될 수 있음. 하지만 한사람은 여러개의 직업을 가질 수 없음 (한사람의 직업은 오직 하나라고 가정하에)  
   N-N: 테이블 A의 한 레코드가 테이블 B의 여러 레코드와 연결될 수 있고, 테이블 B의 한 레코드가 테이블 A의 여러 레코드에 연결 될수 있는 경우
        ->관계테이블을 꼭 만들어 준다(이유: 스키마에서 관계표현 참고)  

   - 스키마에서의 관계표현(기본키 : PK, 참조키 : FK)
          1-N : N쪽에서 화살표가 있는 실선을 해당되는 칼럼을 연결
        
          N-N : 양쪽에 화살표가 있는 실선을 사용해서 해당되는 칼럼 연결 BUT 스키마에서 N-N관계 테이블은 존재할 수 없음 (데이터 중복)
             =>연결(관계)테이블을 사용하여 1-N관계로 변형

   - 분리된 테이블에서의 정보 추출 -> 8장 조인, 9장 서브쿼리, 10장 셀프조인,유니온
 
 DB 설계 >> 데이터의 관계 파악


   DB설계의 과정
    - 업무에 대한 파악이 우선 
    - 데이터 구상
    - 1-1, 1-N, N-N관계 파악
    - 1-N관계는 별도의 테이블로 나타냄
    - N-N관계는 연결(관계)테이블을 사용해 두개의 1-N 관계로 만듦
    - 만약 정규화를 위반하는 테이블->정규화 작업을 통해 3NF( 제 3정규화)가 되게 함 
   

 DB 설계 >> 정규화 (1NF)

  - DB설계시 고려 사항
     중복 데이터 없애기(1-N,N-N 등의 테이블 분리)
     정규화 규칙 따르기 (1,2,3NF)
        - 데이터의 중복을 최소화 공간 확보
        - 예기치 못한 에러의 발생 가능성을 최소화함(필터링 등)
        - 쿼리를 간단하게 하고 효과적으로 실행 시킬 수 있게 함

  - 제 1정규화 
     - 열은 원자적 값만 포함
     - 같은 데이터가 여러 열에 포함되지 않음
     - 1-N,N-N 관계를 파악하여 테이블로 분리하면 해결됨


 DB 설계 >> 합성키(COMPOSITE KEY)

    - 기본키가 없는 연결테이블
       중복성 체크 등의 서비스 => 두개 이상의 열로(toy_id. color)로 만들수 있음 = 합성키 
         -> 합성키는 여러개의 열들로 구성되어  유일무일한 키를 만드는 기본키이다 
       이경우 동일한 합성값을 데이터로 입력할때 에러발생
    
    - 합성키를 설정을 위한 SQL문장
       ALTER TABLE toy_color ADD PRIMARY KRY (toy_id, color);

 
 DB 설계 >> 종속관계
 
   - 종속관계
     테이블을 구성 하는 어떤 열이 다른 열의 변경에 따라 함께 변경되어어야 하는 경우
       만약 어떤 테이블에 이런관계가 있다면 그러한 관계에 있는 것들은 별도의 테이블로 분리하던지 아니면 다른 방식으로 해결해야 종속관계를 없앰. 
       이것이 2,3NF의 기본 개념 
     ex) name(합성키의 일부)이 바뀌면 initial도 바꿔야 한다.( initial열은 name열의 종속관계 )(부분적 종속)
 

 DB설계 >> 부분적 함수 종속
 
   - 부분적 함수 종속의 정의 : 키가 아닌 열이 합성키의 전부가 아닌 일부에 종속되는 경우
      -> 피하는 방법 : 합성키를 사용 하지 않고 새 키를 만들어 제공 OR 별도의 테이블로 분리
  

 DB 설계 >> 이행적 함수 종속
  - 이행적 함주 종속의 정의 : 키가 아닌 열이 키가 아닌 다른 열에 종속되는 경우 
     -> 피하는 방법 : 별도의 테이블로 분리


 DB 설계 >> 제 2정규화 (2NF)

  - 제 2정규화의 조건 
    1. 제 1정규화이어야 한다.
    2. 부분적 함수 종속이 없어야 한다.

    + 합성키가 있는 테이블에 임의의 AUTO_IMCREMENT키를 만들면 부분적 종속관계 없어짐
         ->키의 일부분이라는 개념 자체가 없으므로
       BUT 이행적 종속 관계는 남아 있을 수 있음 (3NF에서 해결) 
    + 테이블의 모든 열이 합성키의 일부분이면 제 2정규화(당연)


 DB 설계 >> 제 3정규화 (3NF)

  - 제 3정규화의 조건
    1. 제 2정규화 이어야 한다.
    2. 이행적 함수 종속이 없어야 한다.










